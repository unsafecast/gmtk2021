{"mappings":"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","sources":["src/renderer.ts","src/state.ts","src/collidingEntity.ts","src/entity.ts","src/player.ts","src/testingScene.ts","src/scene.ts","src/index.ts"],"sourcesContent":["\nexport class Renderer {\n    public clearColor: string = \"black\";\n    \n    constructor(elem: HTMLCanvasElement) {\n\tthis.canvas = elem;\n\tthis.canvas.width = window.innerWidth;\n\tthis.canvas.height = window.innerHeight;\n\t\n\tthis.context = this.canvas.getContext(\"2d\");\n\tthis.context.scale(2, 2);\n    }\n\n    drawRect(x: number, y: number, w: number, h: number, style: string = \"white\") {\n\tthis.context.fillStyle = style;\n\tthis.context.fillRect(x, y, w, h);\n    }\n\n    drawImg(img: Image, x: number, y: number, w: number, h: number) {\n\tthis.context.drawImage(img, x, y, w, h);\n    }\n\n    clear() {\n\tthis.context.fillStyle = this.clearColor;\n\tthis.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n}\n\n","import { Renderer } from \"./renderer.ts\";\nimport { Entity } from \"./entity.ts\";\nimport { Scene } from \"./scene.ts\";\n\nexport class State {\n    private images: Dictionary<string, Image>;\n    private rend: Renderer;\n    private curScene: Scene;\n\n    public keysPressed;\n    \n    constructor(images: Dictionary<string, Image>) {\n\tthis.images = images;\n\tthis.rend = new Renderer(\n\t    document.getElementById(\"main-canvas\") as HTMLCanvasElement\n\t);\n\n\tthis.curScene = null;\n\tthis.keysPressed = {};\n\n\twindow.addEventListener(\"keydown\", (event) => {\n\t    this.keysPressed[event.key] = true;\n\t});\n\n\twindow.addEventListener(\"keyup\", (event) => {\n\t    this.keysPressed[event.key] = false;\n\t});\n    }\n\n    setScene(scene: Scene) {\n\tthis.curScene = scene;\n    }\n\n    start() {\n\twindow.requestAnimationFrame(this.tick.bind(this));\n    }\n\n    tick() {\n\tthis.rend.clear();\n\n\tthis.curScene?.tick();\n\tthis.curScene?.draw(this.rend);\n\t\n\twindow.requestAnimationFrame(this.tick.bind(this));\n    }\n}\n\n","import { Entity } from \"./entity.ts\";\nimport { State } from \"./state.ts\";\n\nexport class CollidingEntity extends Entity {\n    constructor(state: State, image: Image) {\n\tsuper(state, image);\n\tthis.canCollide = true;\n    }\n    \n    collided(entity: Entity) {\n\tthis.x -= 5;\n\tif (this.collidesWith(entity)) {\n\t    this.x += 10;\n\t}\n\tif (this.collidesWith(entity)) {\n\t    this.x -= 5;\n\t    this.y -= 5;\n\t}\n\tif (this.collidesWith(entity)) {\n\t    this.y += 10;\n\t}\n    }\n}\n\n","import { Renderer } from \"./renderer.ts\";\nimport { State } from \"./state.ts\";\n\nexport class Entity {\n    private image: Image;\n    private state: State;\n\n    public x: number = 0;\n    public y: number = 0;\n    public w: number = 32;\n    public h: number = 32;\n\n    public canCollide = false;\n\n    constructor(state: State, image: Image) {\n\tthis.image = image;\n\tthis.state = state;\n    }\n\n    tick() {\n    }\n\n    draw(rend: Renderer) {\n\trend.drawImg(this.image, this.x, this.y, this.w, this.h);\n    }\n\n    collidesWith(entity: Entity): boolean {\n\tconst left1 = this.x;\n\tconst right1 = this.x + this.w;\n\tconst top1 = this.y;\n\tconst bottom1 = this.y + this.h;\n\n\tconst left2 = entity.x;\n\tconst right2 = entity.x + entity.w;\n\tconst top2 = entity.y;\n\tconst bottom2 = entity.y + entity.h;\n\n\treturn left1 < right2 &&\n\t    right1 > left2 &&\n\t    top1 < bottom2 &&\n\t    bottom1 > top2;\n    }\n\n    collided(entity: Entity) {\n    }\n}\n","import { Entity } from \"./entity.ts\";\nimport { CollidingEntity } from \"./collidingEntity.ts\";\nimport { State } from \"./state.ts\";\n\nexport class Player extends CollidingEntity {\n    constructor(state: State) {\n\tsuper(state, state.images[\"localDuck\"]);\n\tthis.canMove = true;\n    }\n    \n    tick() {\n\tsuper.tick();\n\n\t// Temporary obviously\n\n\t    if (this.state.keysPressed['a']) {\n\t\tthis.x -= 5;\n\t    }\n\t\n\t    if (this.state.keysPressed['d']) {\n\t\tthis.x += 5;\n\t    }\n\n\t    if (this.state.keysPressed['w']) {\n\t\tthis.y -= 5;\n\t    }\n\n\t    if (this.state.keysPressed['s']) {\n\t\tthis.y += 5;\n\t    }\n    }\n}\n\n","import { Scene } from \"./scene.ts\";\nimport { State } from \"./state.ts\";\nimport { Entity } from \"./entity.ts\";\nimport { Player } from \"./player.ts\";\nimport { CollidingEntity } from \"./collidingEntity.ts\";\n\nconst tilemap = [\n    [ 'a', 'p', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a' ],\n    [ 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g', 'g' ]\n];\n\nexport class TestingScene extends Scene {\n    constructor(state: State) {\n\tsuper(state);\n\n\tthis.loadTilemap(tilemap);\n    }\n    \n    tick() {\n\tsuper.tick();\n    }\n\n    draw(rend: Renderer) {\n\tsuper.draw(rend);\n    }\n}\n\n","import { Entity } from \"./entity.ts\";\nimport { State } from \"./state.ts\";\nimport { Player } from \"./player.ts\";\nimport { CollidingEntity } from \"./collidingEntity.ts\";\n\nexport class Scene {\n    private entities: Map<string, Entity>;\n    private state: State;\n    private background: Image;\n\n    constructor(state: State, background: Image = null) {\n\tthis.state = state;\n\tthis.entities = new Map();\n\tthis.background = background;\n    }\n\n    addEntity(name: string, entity: Entity) {\n\tthis.entities.set(name, entity);\n    }\n\n    getEntity(name: string) {\n\treturn this.entities.get(name);\n    }\n\n    loadTilemap(tilemap: Array<Array<string>>) {\n\ttilemap.forEach((row, y) => {\n\t    row.forEach((thing, x) => {\n\t\tlet entity: Entity = null;\n\t\tlet name = \"\";\n\t\tswitch (thing) {\n\t\t    case 'p':\n\t\t\tentity = new Player(this.state);\n\t\t\tname = \"player\";\n\t\t\tbreak;\n\t\t    case 'g':\n\t\t\tentity = new CollidingEntity(this.state, this.state.images[\"grass\"]);\n\t\t\tname = `grass_${Math.random()}`;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (entity != null) {\n\t\t    entity.x = x * 32;\n\t\t    entity.y = y * 32;\n\t\t    this.addEntity(name, entity);\n\t\t}\n\t    });\n\t});\n    }\n\n    tick() {\n\tfor (const entity of this.entities.entries()) {\n\t    entity[1].tick();\n\n\t    // Hehe this looks horrible\n\t    // But do I care? Nah...\n\n\t    // Also inneficient as fuck\n\t    for (const entity2 of this.entities.entries()) {\n\t\tif (entity2[0] != entity[0] &&\n\t\t    entity[1].canCollide && entity2[1].canCollide) {\n\t\t    if (entity[1].collidesWith(entity2[1])) {\n\t\t\tif (entity[1].canMove) {\n\t\t\t    entity[1].collided(entity2[1]);\n\t\t\t}\n\t\t\t\n\t\t\tif (entity2[1].canMove) {\n\t\t\t    entity2[1].collided(entity[1]);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    draw(rend: Renderer) {\n\tif (this.background != null) {\n\t    rend.drawImg(this.background, 0, 0, rend.canvas.width, rend.canvas.height);\n\t}\n\t\n\tfor (const entity of this.entities.entries()) {\n\t    entity[1].draw(rend);\n\t}\n    }\n}\n\n","import { State } from \"./state.ts\";\nimport { TestingScene } from \"./testingScene.ts\";\n\nconst loadImagesAndStart = (images: Dictionary<string, string>, startFun: any) => {\n    let len = Object.keys(images).length;\n    let loaded = 0;\n    let dict = {};\n\n    for (const key in images) {\n\tlet img = new Image();\n\timg.onload = () => {\n\t    loaded += 1;\n\t    if (len == loaded) {\n\t\tstartFun(dict);\n\t    }\n\t}\n\timg.src = images[key];\n\tdict[key] = img;\n    }\n}\n\nconst main = () => {\n    let images = {\n\t\"localDuck\": \"duck.png\",\n\t\"grass\": \"grass.png\",\n    };\n\n    loadImagesAndStart(images, (loaded) => {\n\tlet state = new State(loaded);\n\tstate.setScene(new TestingScene(state));\n\tstate.start();\n    });\n}\n\nmain();\n\n"],"names":["$499bb12dc56c2d764690fa06b0972e34$export$a695173e2ecfa9b","elem","clearColor","canvas","width","window","innerWidth","height","innerHeight","context","this","getContext","scale","[object Object]","x","y","w","h","style","fillStyle","fillRect","img","drawImage","$3bf3b04a899cbbe9a92c99cd4cfcddb4$export$9a41e7f313711121","images","rend","document","getElementById","curScene","keysPressed","addEventListener","event","key","scene","requestAnimationFrame","tick","bind","clear","draw","$8ff6e72e0a3f0a39deeac565aaf4a5d5$export$cf7eeb7b1b103837","state","image","canCollide","drawImg","entity","left1","right1","top1","bottom1","left2","right2","top2","bottom2","super","collidesWith","$c9570c4dcb1bbd2c0cee53130fc5828c$export$271aa840ccfeca27","canMove","$042c9726fd898a748ef08a4c9cfe5101$var$tilemap","$042c9726fd898a748ef08a4c9cfe5101$export$ba1f466026b739a4","background","entities","Map","name","set","get","tilemap","forEach","row","thing","Math","random","addEntity","entries","entity2","collided","loadTilemap","startFun","len","Object","keys","length","loaded","dict","Image","onload","src","$a4018e003ec9cbe06ab0cc0137aa4e69$var$loadImagesAndStart","setScene","start"],"version":3,"file":"index.6c2fe369.js.map"}